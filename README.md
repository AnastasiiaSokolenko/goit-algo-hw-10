## Порівняння жадібного алгоритму та динамічного програмування

Ми реалізували дві функції для розрахунку решти покупцеві:

- **find_coins_greedy** – жадібний алгоритм, який бере найбільші доступні номінали;
- **find_min_coins** – алгоритм динамічного програмування, що гарантує мінімальну кількість монет.

### Результати

| Amount | Greedy (sec) |     DP (sec) |              Greedy result |                  DP result |
|--------|--------------|--------------|----------------------------|----------------------------|
|    100 |     0.000002 |     0.000046 |                    {50: 2} |                    {50: 2} |
|    113 |     0.000001 |     0.000048 | {50: 2, 10: 1, 2: 1, 1: 1} | {50: 2, 10: 1, 2: 1, 1: 1} |
|    500 |     0.000001 |     0.000224 |                   {50: 10} |                   {50: 10} |
|   1000 |     0.000001 |     0.000433 |                   {50: 20} |                   {50: 20} |
|   2000 |     0.000000 |     0.000872 |                   {50: 40} |                   {50: 40} |
|   5000 |     0.000000 |     0.002192 |                  {50: 100} |                  {50: 100} |
|  10000 |     0.000001 |     0.004696 |                  {50: 200} |                  {50: 200} |

## Висновки

- **Жадібний алгоритм** працює значно швидше, оскільки його складність `O(k)` залежить лише від кількості номіналів монет (k), а не від величини суми. У реальних касових системах кількість номіналів фіксована та мала (наприклад, 6–8 монет), тому на практиці алгоритм працює майже за `O(1)` — миттєво навіть для великих сум.  

- **Алгоритм динамічного програмування** має складність `O(amount·k)` — тобто час виконання зростає пропорційно сумі, оскільки будується таблиця для всіх значень від 1 до потрібної суми. Він повільніший при великих сумах, але завжди знаходить глобально оптимальне рішення, навіть для нестандартних систем монет, де жадібний метод може помилитися.  

- Для **стандартної системи монет** (1, 2, 5, 10, 25, 50) обидва алгоритми дають однаковий результат.  

- Для **реальних касових апаратів** доцільно використовувати жадібний алгоритм: він швидкий, простий і оптимальний у даній валютній системі.  

- **Алгоритм динамічного програмування** більше підходить для навчальних задач або “нестандартних” наборів монет, де жадібний метод може дати не найкращий результат.
